2019_11_15.txt -PHD --scsi

I will start to organize my code for the next meeting with Suzuki-sensei.
> I want to start from the beginning using a tool to keep track of the changes (log file) and documenting everything, maintaining and organized workflow.

----


2019_11_17.txt -PHD --scsi

The code must have the following characteristics/behaviours:
> Functions declared in a .py file indicate the number of particles entering into the domain trough each particular cell. It also indicates the velocity of the particles. One function for each type of particle. It is important to take into account that the velocity of the particles is a resultant between the velocity due to solar wind, and the velocity due to the temperature of that particular species. The simulation itself must be completely detached from this .py file, just receiving the information from the aforementioned functions and not providing values to the file.
> Outside boundaries are open boundaries. Every particle crossing any exterior boundary is deleted from the simulation. When calculating values in the nodes related to the particles a derivative = 0 approximation will be used. For example: velocity will be considered as the average velocity produced by the particles inside the cells involved in the calculation; density is calculated with the number of particles of such cells, and dividing by half of the usual volume computed for the rest of the cells.
> Cartesian mesh is ok for now, but let's try to keep the code as generic as possible.
> 2D is ok for now.
> I will make the E field in every node an addition between the E-field calculated with the Poisson solver, i.e. the electric field created by the interaction of the Spacecraft with the enviroment, and an external electric field that can vary from node to node. In this first simulation the external E-field will be 0.
> I highly doubt that any B-field created by the Spacecraft will become necessary to take into account at any stage of development of this code. So far, I will just add an external B-field with the same characteristic of the E-field above, being B = 0 for now.
> About the inner boundary, the particles impinging into the Spacecraft will be deleted from the mesh. The function(s) that will handle this part will receive a function that decide the number of electrons or particles created due to the incoming particle. As such, the function(s) must receive an indetermined number of species, because ablation will be included later which would mean than several types of species might be created from this impinging effect.
> The function mentioned above will make use of other function(s) that must register the current density of incoming and outcoming particles, of any species represented in the simulation. It might be passed to the previous function as an argument.
> To prevent any future interest in analyzing particular phenomena related with electrons of different origins from being difficult, the program will keep all these electrons and particles that are identical but from different sources as different species (different classes in the program). This may be organized with implementation of abstract classes, with abstract classes representing particles that are physically different, and inside each abstract class, derived classes with same physical characteristics but with different origin. 
> I think it is better to put the values of current densities in the nodes representing the Spacecraft as attributes of the classes. I should consider, in overall, putting anything related to particles in these classes. If I follow the same practice with electromagnetic fields and the rest of physical entities of importance in the simulation, I might be able to not need the 'world' class at all.
> Abstract classes of different species of particles may derive from an abstract super-class called particle. Something like that may be done with electromagnetic fields. In general, it seems as a good practice to organize this code as an object-oriented program.

----


2019_11_23.txt -PHD --scsi

> So, I am choosing Github as my repository for the code.
> The name of the project will be: SCSi (Solar Corona - Spacecraft interaction).
> At the end of each working session, I should update my computer's version and Github's repository version.
> I will construct abstract classes with 'abc.py' module.
>I will also save and keep updated the logfile "notes-PHD--scsi.txt" which is basically all the entries of this diary up to that day. The command is the following:
2019_11_23.txt rm notes-PHD--scsi.txt && for i in 201*; do awk 'BEGIN{a = 0} /-PHD --scsi/ {a = 1; print FILENAME, $0; next} /\\endInput/ {if (a ==1) print RS; a = 0; next} {if (a ==1) print $0}' $i >> notes-PHD--scsi.txt; done && cp notes-PHD--scsi.txt /home/jorge/Documents/PHD/Simulations/SCSi
> I am doing my class diagram with Inkscape following UML Class Diagram standards (I bookmarked a webpage that is very concise in explaining the standard).
Source: https://www.visual-paradigm.com/guide/uml-unified-modeling-language/uml-class-diagram-tutorial/

Construction of classes:

Notes:
> Mesh and PIC concrete classes (defined type of mesh and PIC) are closely linked. I do not want them to receive instatiation of the other so rather they will both import each other library, and will make use of the methods.
> I still have to think if I will create a Point class, how to recognize boundaries, and where to put areas of boundary points (in order to calculate fluxes).
> Also how to treat particles: Species? Just Particle class? Each particle as an object? Arrays of velocities and positions?
> Because it would be a waste of storage to keep points inside the Spacecraft, I think it is better to build the mesh between the inner and outer boundaries. Then I will create, for every different case of Spacecraft, a new file that will take care of the methods necessary to handle the inner boundary. I want to somehow detach this file and its methods from the methods that will take care of the physical phenomena. Something like this file provides the information whether a particle hit the spacecraft, but does not calculate the current nor deletes the particle. For the methods to handle outer boundaries, same standars will be applied to them. The outher boundary is closer linked to the mesh itself, but I will keep it as separate file to use the same logic as with inner boundaries. Then, every concrete mesh class will import the appropiate inner and outer boundary files, so that from outside, mesh objects can handle everything related to boundaries.
> For the first simulation I will use as the spacecraft a 1m-side cube. Therefore, the artificial depth of my code will be 1m.
> The First and outer boundaries will handle the information of the boundaries, which is why values such as nPoints, nx, ny and so on cannot be provided by the main program. They will be stored at a file called domain.py that will be imported by both boundary files.


Mesh (Abstract)(Association between Mesh and PIC):

Definition = Defines the type of mesh.
Attributes:
	+nPoints (int) = Number of points in the mesh.
	+volumes ([double]) = Volume of each node.
	+pic (PIC) = Object that provides pic methods (Association between Mesh and PIC).
Methods:
	+setDomain() = This function, with the values provided by the boundary files, will create the mesh, by setting up volumes, nPoints and any other subclass variable.
	+getPosition([int] i): [double, double y] = For a each index return its real position.
	+getVolumes() = calculates the volume of each node and stores it in volumes attribute.
	+print() = Print a VTK file / Matplotlib visualization of the mesh (points and connections between particles).

Mesh_2D_rm (Inherits from Mesh):

Definition = Mesh class for a 2D rectangular mesh.
Attributes:
	+xmin (double) = Left limit of the domain (closest to the Sun).
	+xmax (double) = Right limit of the domain (farthest from the Sun).
	+ymin (double) = Bottom limit of the domain.
	+ymax (double) = Top limit of the domain.
	+depth (double) = Artificial thickness of the domain, to make it three-dimensional.
	+nx (int) = Number of nodes in the x direction.
	+ny (int) = Number of nodes in the y direction.
Methods:
	+Implementation of Mesh methods.


PIC (Abstract)(Association between Mesh and PIC):

Definition = Indicate the methods that all PIC classes have to implement. Each PIC concrete class will depend on the type of mesh, as well as the type of PIC algorithm implemented.
Methods:
	+scatter([double, double] positions, double value, [double] field) = Receives the positions of the particles, and makes scatter procedure, calculating the values of field for each node.
	+gather([double, double] positions, [double] field): [double]field_p = Calculates values of the field in particles' positions, returning these values in an array as long as positions, called field_p.

PIC_2D_rm1o (Inherits from PIC):

Definition = PIC class for rm10 ('r'ectangular 'm'esh, '1'st 'o'rder implementation).
Methods:
	+Implementation of PIC class methods.
	+scatter_density = return densities of that species in every node of the mesh.
	+scatter_velocity = return velocities of that species in every node of the mesh.
	+scatter_flux = return flux of particles of that species into every indicated node (not all the mesh).

Species (Abstract):

Definition = This abstract class is the wrapper for everything related to particles. Any species of particles inherits from this class.
Attributes:
	+q (double) = charge of the species.
	+m (double) = mass of the species.
	+q_over_m (double) = q/m.
	+debye (double) = Debye length of the spcies.
	+spwt (int) = specific weight of the species.
	+max_n (int) = max. number of particles for the species.
	+mesh_values (Particles_In_Mesh) = object to store anything related with the particles in the mesh.
	+part_values (Particles) = oject to store anything related to the actual particles in physical space.

Proton (Inherits from Species):

Definition = Species that take care of protons.
Attributes:
	+type (string) = some string descriptor that indicate the type/source of protons.
	+Species attributes.

Electron (Inherits from Species):

Definition = Species that take care of electrons.
Attributes:
	+type (string) = some string descriptor that indicate the type/source of electrons.
	+Species attributes.

Ion (Inherits from Species):

Definition = Species that take care of ions.
Attributes:
	+type (string) = some string descriptor that indicate the type of ion.
	+Species attributes.

Neutral (Inherits from Species):

Definition = Species that take care of neutrals.
Attributes:
	+type (string) = some string descriptor that indicate the type of neutrals.
	+Species attributes.

Particles_In_Mesh (Abstract)(Composition with Species):

Definition = Store values of distributions in the mesh related with particles. It wraps all the attributes that all particles must have.
Attributes:
	+nPoints (int) = Number of nodes in the mesh (Same as mesh class).
	+density ([double]) = Density values at each node.
	+velocity ([double, double]) = Velocity at each node. Rows are different points, columns are (x,y,z) components if they are available.

Electrons_In_Mesh (Inherits from Particles_In_Mesh):

Definition = Actual implementation of Particles_In_Mesh for electrons.
Attributes:
	+flux_spacecraft ([double]) = Perpendicular flux density of electrons going in (+) or out (-) of the spacecraft. The number of rows is the number of points compounding the mesh,
									and each value represents the flux trough the line (area) next to the point (in ant-clockwise direction).
	+Particles_In_Mesh attributes.

Particles:

Definition = Stores values related with the particles themselves. (
Attributes:
	+current_n (int) = current number of particles.
	+position ([double,double]) = Position of every particle. Rows are different particles, columns are (x,y,z) if available.
	+velocity ([double,double]) = Position of every particle. Rows are different particles, columns are (x,y,z) components if available.


----


2019_11_23.txt -STOPIC --github -PHD --scsi

> Differences between "fetch" and "pull": fectch just downloads the new changes into your local repository. pull, besides that, overwrite the new changes in your local files.
> I am installing something called 'hub' that is a project that aims to wrap git and implements from command line usual actions of Github.
> I am configuring Git for my project with 'git config':
	git config --global user.name "Jorge Garcia"
	git config --global user.email "jorge-02@hotmail.es"
> Workflow from computer to server (Github website):
>> Work in my computer.
>> 'git add *': Add every new file to the git local repository. Files are 'staged' (meaning they are registered in my local git repository.
>> 'git commit -m "[Comment]"': Commit every staged file of my local repository.
>> 'git push origin master': Exactly copies the new files and files changed to the destination repository, in this case 'origin', that is an alias for my remote repository in Github. 'Master' is the branch I am pushing.
>> 'git pull origin master': Synchronizes (overwriting) branch 'master' of local repository with remote repository 'origin' ( My Github in my case).

----


2019_11_30.txt -PHD --scsi

I have founnd a document that I put in the "Papers" folder of my "PhD" folder that explains how a Capacitance matrix is created. I have to think more about it, but I suppose the idea is to establish relative capacitances between every two nodes of the mesh and every node with respect to some ground, and then, using the charge in every node from the PIC step, calculate the voltages. Actually, the paper "2009_Evaluation of Electric Field Probe Onboard Spacecraft using a 3D PIC Simulation" and the book "1985_Plasma Physics via Computer Simulation_Birdsall-Langdon" both referred to the book "Computer simulation using particles / R.W. Hockney and J.W. Eastwood" when mentioning this Capacitance Matrix method. There are several copies in UTokyo so I will go on Monday to get one.

----


2019_12_02.txt -PHD --scsi

> Capacitance Matrix: So, what is the idea? The charge at any point in the spacecraft is the integral of net current to the spacecraft in from t=0 to that moment. Then, by using \vec{V} = C^{-1}\vec{Q} with \vec{Q} the charges in the nodes of of the spacecraft, V can be obtained for the same nodes.
> Another idea, called immersed boundary, is to put sufficiently large permittivities in the nodes representing the spacecraft. Using finite \rho, but "almost infinite" \epsilon, makes \nabla\phi almost vanishing, which is the intention for a conducting material.
> The conclussion of the day regarding this topic is: Calculate the charge accumulation at the nodes as mention in the first item. Probably, after each iteration, I should redistribute the charge in a way that makes the potential equal to zero. Then, in next iteration, use this previous charge in each node, plus current*timestep. Now, having this and knowing the C^{-1}, V can be calculated. which will be v_{sc}*\vec{1}. As such, the only part remaining is to find the capacity matrix. For this I have to solve the problem of finding the potential for a square at fixed potential as inner boundary, and infinite as outer boundary. I think is viable to make \phi = X(x)Z(z) and work with one quarter of the space. The potential in the diagonal boundary has to satisfy that \vec{E} perpendicular to the diagonal equals 0. Obviously, the other two boundaries are V(sc) = v_{sc} and v(\infty) = 0. Then, using Gauss law in the spacecraft, find v_{sc} such that the charge is 1. After this, make \frac{d\phi}{dz} to find the charge density and thus store the values of how a total charge Q is redistributed throughout the surface of the spacecraft.

----


2019_12_09.txt -PHD --scsi -MAESTRIA --transitorio_1D

> I can use the computer in front of the table and the MacPro one. For both of them I should check if I will interrupt or somehow affect other people's code and ask for permission.
> In the computer in fron of the table I will use Conda to run the code. Commands to use Conda:
>> conda activate jorge
>> conda deactivate

> So far, the code in /home/jorge/Documents/Instituto_Balseiro/Documentos_Maestria/Simulaciones/Preliminary_Version/source_FifeThruster is working. I will copy that version into Hayabusa 3. I also updated the error of the energy term Jj in the Dropbox folder. I corrected the (+) to (-) in the exponential term in ionization.
> I put my Master's code into Github. I have to ask Daniel about privacy issues, but in general I want to keep stored a version of the code that works, alongside my thesis and some other documents.

> The code will be working with mks system, at least for now.
> The constants of the mesh not related to the boundaries are directly written in the init function of the class.
> Addition to mesh_2D_rm:
Definition = Mesh class for a 2D rectangular mesh. The organization of the points will work as 0<=i<nx and 0<=j<ny. Also, for k parameter 0<=k<nPoints, k = nx*j+i.
#       +dx (float32) = Distance between adyacent horizontal nodes
#       +dy (float32) = Distance between adyacent vertical nodes



----


2019_12_12.txt -PHD --scsi -STOPIC --python

> After deliberating for a bit, I have decided to maintain all the classes' codes with self. I think it is clearer to read it that way afterwards and reduces the probability of coding errores related with differentiating when to declare variables and functions as class or instance attributes. I show the discussion below:
"So far I am using 'self' to define the attributes inside the classes. That means that the attribute is considered as an instance attribute rather than a class attribute. Same with functions define with 'self' as first argument. For now I will stop using 'self' in the classes that will be instanced just once, since I am adding this four additional letters unnecessarilly each time. Maybe in the future I can start using, for example, different PIC techniques for different parts of the domain, or a mesh that is a combination of different meshes. In those cases I might be instantiating multiple times the same class, and I will need then to change the code. I will stop using self for variables and I will declare them in the class scope. However, methods will still include 'self' since otherwise, to be part of the class, 'self' has to be replaced by 'cls', and it goes through more work since class methods then possibly cannot be called as instance.function_name()"

> New addition to Mesh class:
#	+getIndex([double,double] pos): [double,double] = For each real position returns its index value. Important to remember that the number of columns may vary
#           depending on the actual type of mesh subclass used.
Also, now it's not necessary to use getVolumes() so it was deleted.

----


2019_12_17.txt -PHD --scsi

> Now the classes Mesh and Mesh_2D_rm work! I printed the mesh in paraview and everything is working as expected: volumes and coordinates.
> Correction in PIC class:
#	+scatter([double, double] positions, [double] values, [double] field) = Receives the positions of the particles, and makes scatter procedure, calculating the values of field for each node.

----


2019_12_18.txt -PHD --scsi

> So, the Mesh class was receiving an instance of PIC, but PIC needs to know what kind of Mesh is being used. Considering that PIC class needs the Mesh instance for its functions, this class has prevalence over Mesh. On the other hand, conceptually speaking, one particular mesh may hold different PICs, or, saying in better terms, several PIC classes may be based on the same Mesh, but not the opposite. With that said is like particular class Mesh -> several PIC classes. So, Mesh has to be initialized first.
> I deleted PIC from the attributes of a mesh and add the mesh as attribute to PIC.
> New additions to mesh:
	+arrayToIndex([ind] array): [int, int] = For the indexes in the 1D array, obtain the indexes used for the particular mesh.
	+indexToArray([ind, ind] index): [int] = For the indexes used for the particular mesh, obtain the 1D version for the array.
> When translating code from my Master's code to SCSI, that SCSI is using nx and ny as nodes, but in my Masters are number of cells.
> I am deleting the rows that took care of the particles at the edge (i = nx or j = ny) so now I will start considering that particles at those positions are removed. I think that will create a faster and easier code, with no perceptible losses in numerical precision.
> There have been many small changes in the definitions of functions in PIC and PIC_2D_rm1o.
> Species has to be declared after the Mesh, so that the attributes of Mesh can be used to define Species.

----


2019_12_19.txt -PHD --scsi

> I will make a class Field, subclasses Electric_Field, Magnetic_Field, with the functions related with fields and interactions of these fields with the particles. These classes will have as attribute the file that contains the functions which handle with the boundaries of the fields. They will also have as import the file 'field_solvers.py' that compute the fields.
> I am also implementing a boundary class that will handle methods related with boundaries. This is for later work, so let's write it down: The Abstract class may contain different methods already developed that are more general, like applying a Neumann boundary or a Dirichlet boundary to some nodes, then the subclasses can use these methods for their specific; this is to prevent too much code copy-pasting with every new version of a boundary. Also, it might be a good idea to put as an attribute of boundary, an array with the indices of the nodes that represent that boundary. Actually that last one I will use it.
> So far I have been repeating many attributes through different classes. I will keep it like that for now because I am trying to make the first functioning version of the program, but at some point it will be good to review those redundancies.
> [IMPORTANT]: There will be many 'boundary line units' in the code. Everytime working with them, they will be represented by the node next to them in anti-clockwise direction. In other terms, for every node, its line will be next to it in clockwise direction.
> Inject particles contains a lot of information on how the workflow of the program works. New attributes to mesh, to Particles_In_Mesh.

----


2019_12_21.txt -PHD --scsi

> I forgot to mention that I am injecting the particles in injectParticleFace in volumes that have the nodes at their center, different from the previous approach in the Masters' code where the volumes where determined as the volume in front of the areas which were the working units, with area meaning the regions delimited by the nodes.
> I could consider using numba for some 'for' loops in my code, as a midway of accelerating the code later on.
> Something to care about in the future, in particular the last part.
#       NOTE: This function needs to be revised. random should not spread throughout different cells, and should use the same seed for every function call.

----


2019_12_22.txt -PHD --scsi

> Now mesh, boundary, outer_2D_boundary, species and pic are "compiling". injectParticlesFace function has the potential to be further generalized and thus be used as the common method to insert particles troughout the whole mesh, but so far some of its line are mesh-dependant so it needs to be revised.
> As the first try on my code I am using as input the values showed by guillemant2013simulation.
> Right now dx = 0.25, and despite protons moving around 0.025 at max. per timestep, electrons due to its lighter mass and thus its higher thermal velocity move around 0.3. Because of this I will make a nested loop for electrons movement, with e_dt being 10 times smaller than p_dt.
> Electron acceleration gained during its travel trhough the domain is approx 1/2 of the velocity due to its temperature. It will not influence the mesh for now because the dx is 10 times higher than the distance per timestep without acceleration, but be careful in the future.
> In gather function, in pic.py, I think osme lines may be optimized later.
> Besides the classes presented in class.txt, the code works with no class files like constants.py, main.py and output.py.
> Another note about optimizing in output.py.

----


2020_01_07.txt -PHD --scsi

> When explaining the idea behind the use of 'residuals' to Sano, I realized that something sounded weird there. If I am storing the fractional part in every step and then adding to the next, besides also adding a random fraction between 0 and 1, I am introducing more density than expected. One more particle in every step increase the density by 3e-8, which is 1/23 of the density being used right now. Now, to solve the issue of losing always a part of the density, we could just add every step the residuals, without the randomnes, but that would create a "breathing" phenomenon in the simulation. I thing that a good idea is to just add the random number. The more you loose when truncating, the more probable this random number will aggregate a new particle every step.
> Besides, I have to check the boundary part x=xmin, x=max in injectParticles, since in my code particles being at x=min and x=max are eliminated.

----


2020_01_15.txt -PHD --scsi

> So far the line of thought regarding INJECTION OF PARTICLES goes like this: 
>> Currently I am injecting particles just in the left face, and eliminating particles as they cross the boundaries. I have to check it again, but I think this approach is creating a distribution of less particles than expected near all the boundaries except for the left face. One trick would be to treat top and bottom boundaries as mirrors, reflecting particles (this is done in paper ..., for example). Two issues with this: First, particles affected by whatever happens in the domain (different velocity, trayectory, etc.), instead of going away from the domain, would reflect back, interacting again with the domain, creating non-physical interactions. Second, the idea of mirroring particles is to simulate the idea of what would happen in reality: some imaginary border is created, some particles leave the domain and some others enter. The new particles entering into the domain have not previously being affected by the domain. Mirroring particles would produce a different physical situation at the boundaries. This problems would disappear with a domain big enough, so that things happening inside the domain are not that strongly affecting the boundaries, but this computationally costly. Maybe an improvement over the mirroring technique would be to reset the velocity of the reflected particles to a MB-distribution. That would leave concentrations of particles in some regions of the boundary, due to the effects of the physics inside the domain, as the only non-physicial boundary effect.
>> Another idea is to inject particles in all the boundaries, taking into account the correct density expected for free stream, which involves which injection box to choose and what velocities to provide for the particles.
> Dummy box: To solve all this seemingly complicated problems: insert a dummy box. Since you are providing a MB-distribution before the effective domain, the technique assures that at the boundary of the domain you're receiving the correct distribution. Because the dummy box empties over time, it is necessary to refresh it each time. It is important that velocities should follow the expected velocity distribution and that position should be random. In that way, particles with all the range of velocities will go into the domain.

> So far the new function is not mesh-independent and is not so efficient. I think I might avoid the part of adding particles and just send the arrays to the advance function.

----


2020_01_16.txt -PHD --scsi

This is the new Boundary class. The documentation was updated and the methods for dummy box injection are being created. Notice that createDummyBox is expected to be solved in every subclass, depending on the geometry of the boundary and the mesh.

> CreateDummyBox: I wonder if the thing I am doing right now is more or less efficient than a python for, since I am going trough location array many times.

--------------------------------------------

Boundary (Abstract-like: will also have common methods that can be used by sub-classes. In composition with mesh):

Definition = Class that shows the methods and attributes needed for each particular boundary arrangement.
Attributes:
	+type (string) = string indicating the type of boundary. It will be of the form "[Inner or Outer] - [Sorce, e.g. Spacecraft, Component, etc.]".
	+location ([int]) = array containing the indices of the nodes that the boundary represents.
Methods:
	+applyElectricBoundary([double]) = Applies the boundary condition to the electric field passed as argument.
	+applyMagneticBoundary([double]) = Applies the boundary condition to the magnetic field passed as argument.
	+applyParticleBoundary(Species) = Applies the boundary condition to the species passed as argument.
    +createDummyBox([ind]location, PIC pic, Species species, [double] delta_n, [double] n_vel, [double] shift_vel) = create the dummy boxes with particles in them.
   
Methods stored here for convenience:
    +injectParticlesFace(self, location, pic, species, delta_n, n_vel, shift_vel): 
   	++Function that inject particles into the domain.
   	++Parameters: 
   	++location ([ind]) = Nodes indicating the faces where the particles are going to be inserted. Each node represents the volume surrounding it. Location should be ordered increasingly.
   	++pic (PIC) = Instance of PIC for calculations. It also constains mesh, which is used in the function.
   	++species (Species) = Species to be inserted. It contains inside Particles_In_Mesh 'residuals' which is for each node the values of remnants from the insertion at the previous step.
   	++delta_n ([double]) = For each node in location, the density that is going to be inserted at this timestep. The array is ordered with the order of the nodes in mesh.
   	++n_vel ([double,double]) = For each node in location, the thermal velocity (for a the MB distribution) that the inserted particles will represent. Same order as delta_n.
	++shit_vel ([double, double]) = For each node in location, an added velocity that does not come from temperature origin (like solaw wind average speed.

	+injectParticlesDummyBox([int] location, PIC pic, Species species, [double] delta_n, [double] n_vel, [double] shift_vel) = Inject the particles in location indices by creating dummy boxes around them, creating particles
		inside of them, moving the particles, and then adding the ones that entered into the computational domain.

    +addParticles(Species species, [double, double] pos, [double, double] vel) = Add to Species the new particles, each represented by a row in pos and vel.
    +removeParticles(Species species, [ind] ind) = Removes the particles from species stored at 'ind' positions.
    +sampleIsotropicVelocity(double vth, int num) = It receives the most probable speed vth = \sqrt{2kT/m} and creates num random 2D velocities with their magnitudes following a Maxwellian distribution.

--------------------------------------------

> I created a "dashboard.py" file where I will be storing all chunks of code that for whatever reason are not necessary for the code, but might be of use in the future.
> I am storing the last results which were run with 'injectParticlesFace' function.

----


2020_01_17.txt -PHD --scsi

> The implementation of the dummy box works, and besides the not so elegant 'createDummyBox' function, everything else in the code is organized.
> So, I will start implementing the particle tracker. In applyParticleBoundary I will insert an argument 'True' or 'False'. If true, it will call the function to delete particles from the storage of particles being tracked. In addParticles I will do the same, adding new particles to track. The storage will be handled as a list of instances of a class called 'Species_Tracker'. It will contain a numpy array of the indices of particles being tracked at any moment (indices with respect to position in part_values). The array will have the number of rows as the number of particles to be tracked, first column being the indentifier of the particle (from 0 to num-1) and the scond column being the index in part_values arrays. Ok, I will make just one column with the index in part_values, since the position of the index in the array can be used as the identifier of the tracked particle. If a particle is deleted, the index will change to 'numpy.nan'. addParticle will check for nans and will add the necessary amount of particles. Since injection of particles occurs after advance of particles, when the program reaches the stage of printing, no row shoule be nan. {Note: however I would like to check how vtk files handle 'nan' values, to make it compatible rather than raising an unwanted error}. There will be a class 'Tracker' that will receive a variable number of arguments will all the species that the user wants to track, and will create the list of instances.
> I might try as well to put inside the Tracker class a function that does the graph. Advantages: Maybe I can have as a default the graphing parameters from the last execution. Disadvantages: I would need to open a python shell, import the file and then run the function.
> Maybe is more organized to add the attribute of 'type (string)' in species, create the string step by step in the 'init' functions of each class. Say: Proton_SW uses super().__init__ where the string is "Proton - " and then Proton_SW adds "Solar wind".
> Later I could pass arguments to Tracker as tuples '(species, num)' with 'num' being the number of particles to be tracked.

Meeting:

> How complicated is the mean of transportation and set up such that the figure is not affected by the enviroment before the experiment?

----


2020_01_18.txt -PHD --scsi

> I am adding to the class Species_Tracker the following line:
self.position = species.part_values.position
Since Python works with references, the burden of memory for the program is just the cost of storing a pointer to a memory address (4 bytes for 32-bit systems and 8 bytes for 64-bits system). Besides, this has the advantage of a pointer, a.k.a. I can modify species.part_values.positions and the changes will appear at self.position too. I am not sure this is the most efficient way of building the code, though.
> So, I am totally changing the apporach to the particle_tracker treatment. Basically I will have a print function in output, and I will also put these arrays of the indices to be used to track the particles, inside each species that is going to be tracked, alongside a Boolean "tracked" that will indicate whether the species needs the treatment in removeParticles and addParticles. In that way there is no need to pass arguments to the functions. Because the species are being treated as different variables in the main, I will just pass the necessary species to the 'print' function, and I will include and assertion to check whether the species effectively are being traced. In order to reduce the usage of memory and make the code more detachable, I will include a "num_tracked" variable in every Particles of size uint16 (0 to 65535). If it is 0, then the species is not being tracked. If more particles are being tracked, the size of this variables needs to be increased. Keep in mind that the python 'Boolean' object costs 28 bytes whereas the uint16 costs 26. If I want to keep things efficient, the type of the array "trackers" should be the same type as 'max_n' and 'current_n'.

----


2020_01_19.txt -PHD --scsi

> When certain tracker is not following a particle, its value is not going to be "numpy.nan" anymore but "species.part_values.max_n". numpy.nan works as a float in Numpy, so I cannot create these arrays of indices having nan inside. On the other hand, these arrays already had the need to handle the biggest possible index, i.e. max_n-1, and max_n as an index will never appear, so I think it is pretty good.
> The code developed to handle the trackers in removeParticles has been tested in test.py succesfully {And I think is pretty awesome how it works {:D}}.
> The 'graph_particle_tracker' file works! I would like later to redefine how I choose the particles to be tracked, since right now most of the particles from each species are being selected at the same time, so they are showing a particular group of them and not a more random general group. Also, I would like to break the particle tracker lines once the particle as been deleted and recplaced by another one.

----


2020_01_20.txt -PHD --scsi

The code now works in the stage of free stream of particles, still not interacting through electromagnetic forces. Particle Tracker tool is not working well. It seems that after the deletion of particles, the new particles selected are not the same through every step. The highest chances are that my code of saturday night is not working correctly, because even some particles that surely don't disappear, look like they do.

----


2020_01_31.txt -PHD --scsi

> I modified 'Field' class by eliminating nPoints and boundaries. It was not necessary since all that information is contained inside mesh, inside pic, and even gives more freedom for later variations of the code.

----


2020_02_07.txt -PHD --scsi

> Last time there was work on preparing everything for the poisson solver except for the methods that go inside solver.py.
> I am following the book "Computer Simulation Using Particles" in the implementation of he Poisson Solver. I am including as an argument the potential of the previous step so that the solution is reached in less time.
> Spectral radius is the largest absolute value among the eigenvalues of the matrix.

----------------------------------

# Method that computes the electric potential for a 2D rectangular mesh using the method of
# Successive Over Relaxation with Chebyshev Acceleration (SORCA). The method assumes that the 
# boundaries has been treated previously and assumes a Dirichlet boundary, so it only calculates values
# for the inner nodes. If a Neumann condition is desired, then the outer layer nodes are calculated correspondingly 
# in the later method apply applyElectricBoundary(e_field), not here.
# rhs is the right-hand-side of the equation Poisson(\phi) = rhs, pot is the potential before being updated, and
# err is the maximum variation expected between succesives steps to reach solution.
def poissonSolver_2D_rm_SORCA(mesh, pot, rhs, err = 1e-3):

----------------------------------

----


2020_02_08.txt -PHD --scsi

> For the implementation of the derivation of the electric potential I will use the typical second order in the inside of the mesh, and for the border it will be Dirichlet. The derivation in the inside of the mesh will be carried out by the method "derive_2D_rm" in solver.py, whereas the boundary nodes will be handled by the method "applyElectricBoundary" in outer_2D_rectangular.py. It is strange but the boundary will regulate the derivatives through field -> solver; in that way the outer_2D_rm class remains separated from the election of the different methods to derivative, and it makes more sense for the Electric_Field class to handle how to manage the boundary. Also in that way I can store the method of derivatives at the boundaries in solver.py. The derivatives used are Pade 2nd order.
> The code of the Poisson solver and subsequent calculation of EF has no syntax error. Only remaining include an acceptable initial condition so that the code don't explodes (so far I executed it and it reached the step_limit with a big error).

New methods:

----------------------------------

#       +Computation of Dirichlet boundary condition at every node in location ([ind]). Every row in value ([double]) corresponds to one node in location.
    def dirichlet(self, location, values):

#       +Derivation of the scalar field potential ([double]) with the method of central differences, at nodes not in the boundaries.
def derive_2D_rm(mesh, potential):

#       +Pade derivation for the nodes in the boundaries. Normal 2nd order derivation when the boundary is perpendicular to the direction of the derivative.
#       +Arguments:
#       +location ([ind]) = location of the boundary nodes to be treated.
#       +mesh (Outer_2D_Rectangular) = mesh with the information to make the finite difference.
#       +potential ([double]) = scalar to be derivated.
#       +Return: [double, double] two-component derivation of potential, with every row being one node of location.
def derive_2D_rm_boundaries(location, mesh, potential):
----------------------------------

----


2020_02_09.txt -PHD --scsi

> Change of methods' names:
>> output_vtk -> saveVTK
>> particle_tracker -> particleTracker
This, to maintain the protocol of mostly using first-word-lower-case then first-letter-next-words-upper-case for methods.

> Now I am setting the gears for storing the simulation at a given moment as '.pkl' and being able to use it as initial condition for a later simulation. To maintain it relatively modular so that I don't have to modify the methods each time a new species or field is included in the simulation, I will pass as arguments fo the 'savePickle' and 'loadPickle' the instances of classes that are going to be stored or loaded. Accordingly, these methods will receive these theings as argvs* so that they do not need to know which kind of instances or how many instances are going to be stored or loaded. For a particular moment in the construction of the simulation, obviously, the number and order of instances have to be the same for both methods. Also, for the sake of organization, a particular order of the instances is to be followed: ts (timestep); fields: Electrics, Magnetics; Species: Electrons, Protons, Ions, Neutrals; part_solver (Particle Solver). Notice: 1. Plurals because there might be more than one Electric Field, Electron Species, etc. 2. part_solver contains PIC and PIC contains mesh. These latter two as o be unravel later in the main function. Inside the types not further specified now, an alphabetical order with respect to the classes' names will be maintained. This ordering may be modified in the future as the simulation grows.
>> Oh, obviously: now a version of the last step of the simulation will be always kept stored, so as to use for 'savePickle'.

> I am also setting things for 'saveVTK' method to function more modular and for using '.vtk' files as initial conditions for new simulations.
>> 'saveVTK': Since the order doesn't matter here I don't need to put much emphasis into this, but I will follow the same order as with 'savePickle' and 'loadPickle' {Because, who knows?}. That being said, 'saveVTK' will function as these two methods: it will receive an undetermined amount of arguments. Each argument is a class with an 'saveVTK' method that will be called and will return a dictionary containing the string names of the scalar/vector distributions with its corresponding portion of code for storing them in a '.vtk' file. 'saveVTK' will iterate over all the arguments and will prepare everything to be printed in one '.vtk' file.
>> As such, the 'loadVTK' function to be used for setting the initial condition of the new simulation has to have some knowledge of the things stored at the desired '.vtk' file. This is going to be handled in the same way as with '.pkl' files. 'loadVTK' function will have an undetermined amount of arguments, and the user has to provide the instances of classes desired to be extracted from the '.vtk' file. Each class knows what kind of scalar/vector distribution needs to function properly, and under which name is identified in the '.vtk' file. As such, the general 'loadVTK' function will be calling 'loadVTK' methods of each instance passed as argument.

> Temperature distribution will be included in every species' information through an attribute of 'Particle_In_Mesh'. When implementing, let's not forget that to calculate temperature at a given 'n' step is important to calculate first the mean between the steps 'n+1/2' and 'n-1/2' for velocity. Actually, I should do that for velocity as well for when is to be printed for later post-simulation analysis.

> To easily handle variations in the simulation regarding the number of species and fields simulated, I will create a class in 'main.py' called 'System'. This 'System' class is simply a wrapper for all the instances of the different classes that are necessary for the simulation to run. It will even contain 'ts' as an atribute. It will have two methods: 'arrangePickle' and 'arrangeVTK', which return the necessary attributes for saving and loading, in the correct order. I will write this code in 'main.py' to keep the  manipulation of the system and the simulation in one file, for ease of modification.

----


2020_02_10.txt -PHD --scsi

> I realized that every time I am injecting particles into the domain, I have to rewind the velocity to math the LeapFrog condition. I corrected that on InjectParticlesDummyBox. I also noticed that this is the case only for LeapFrog, but different time integrators may require different estrategies for making the particles 'ready' for advancing on time the first time. Because of that, the method 'initialConfiguration' of the class 'Motion_Solver' is the one that is supposed to deal with that. To make it useful for "injecting-particles" methods in different stages of the simulation, I removed the 'updateMeshValues' responsability. New Adjustments:

----------------------------------

#       +initialConfiguration(Species, Field) = Make necessary adjustment to the initial configuration of species so as to begin the advancement in time.
#           So far just E, so [Field]->Field.
    def initialConfiguration(self, species, field):

----------------------------------

#       +injectParticlesDummyBox([int] location, PIC pic, Field field, Species species, [double] delta_n, [double] n_vel, [double] shift_vel) = 
#               Inject the particles in location indices by creating dummy boxes around them, creating particles
#       	inside of them, moving the particles, and then adding the ones that entered into the computational domain.
    def injectParticlesDummyBox(self, location, part_solver, field, species, delta_n, n_vel, shift_vel):

----------------------------------

> The plan for 'saveVTK' and 'loadVTK' is to save is to use as the names of the fields in VTK files, the actual names of the attributes in the code. The function, though declared in 'Species', will be handled by 'Particles_In_Mesh'. 'Species' will add the prefix of the type of particle.

> Several changes were done to the main.py file to include the new initial conditions. Shown below.

----------------------------------

## ---------------------------------------------------------------------------------------------------------------
# Initiating data structures for the system
## ---------------------------------------------------------------------------------------------------------------


#System:
#
#Definition = Is the class that contains every variable and class necessary for the simulation to be executed.
#Attributes:
#	+ts (int) = Timestep of the simulation.
#	+The rest of the variables will change with the simulation, but normally, there are:
#	+mesh (Mesh).
#	+pic (PIC).
#	+fields (Field) = Probably several of them.
#	+species (species) = Probably several of them.
#	+part_solver (Motion_Solver).
#Methods:
#	+Remark about init(): It will "declare" the attributes necessary for the simulation to run. The actual assignment of atributes
#		to instances of each class will occur during the 'initial condition' section of 'main.py'.
#	+arrangePickle() : Variable = Return the attributes necessary to store the state of the system, in the order required.
#	+arrangeVTK() : Variable = Return the atrributes for save and load of/from VTK files, in the "order required".
...

#Initialization of the system and the previous step
...

## ---------------------------------------------------------------------------------------------------------------
# Initial condition
## ---------------------------------------------------------------------------------------------------------------
# Initial conditions are selected with a number next to the file when the program is executed, e.g. 'python3 main.py 2'.
# If the initial condition requires more arguments, they are written here in the file.
# Listed Initial conditions:
# 1: Basic empty system.
# 2: Execution from a VTK file.
# 3: Execution from a Pickle file.
...

## ---------------------------------------------------------------------------------------------------------------
# Set up of the system before the Main loop
## ---------------------------------------------------------------------------------------------------------------

## ---------------------------------------------------------------------------------------------------------------
# Main loop
## ---------------------------------------------------------------------------------------------------------------

----------------------------------

----


2020_02_11.txt -PHD --scsi

> Now the name of the species is called 'name', not 'type', and is stored directly in 'Species' class. The string is constructed along the constructors of subclasses. Type of species add the first word, and source adds the second. e.g. for protons in the solar wind, 'Proton' class receives " - Solar wind" and returns "Proton - Solar wind".
> The class 'Field' and its subclasses suffered the same change. Now 'type'->'name' and the attribute is found in 'Field' but constructed through classes.
> saveVTK and loadVTK were implemented for 'Species' and 'Field' under the same signature, to maintain saveVTK and loadVTK functions in output generalized. Nevertheless, they function different. In Species, the bulk of the process is handled y 'Particle_In_Mesh' and 'Species' only functions as a tunnel, also providing 'name'. In 'Field', functions are called directly from the most bottom-level class were they are implemented, and functions are constructed fractionally aong different levels of classes.
> In order to maintain 'Field' and 'Species' independent of the type of mesh, and making 'Mesh' the sole handler of the type of mesh, three new functions were included for the process of VTK I/O:

----------------------------------

#       +vtkOrdering(array): array = The array received as argument is ordered in such a way it can be stored ina VTK file.
#           The result is returned as a new array.
#       +vtkOrdering(array): array = The array received as argument comes with vtk ordering and is reshaped to be stored properly in the code.
#       +vtkReader(): Reader = Return the reader from module vtk that is able to read the vtk file.
#		+saveVTK(string filename, dict dictionary) = It calls the appropiate method in 'vtk' module to print the information of the system in a '.vtk' file.

----------------------------------

----



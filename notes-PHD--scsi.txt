2019_11_15.txt -PHD --scsi

I will start to organize my code for the next meeting with Suzuki-sensei.
> I want to start from the beginning using a tool to keep track of the changes (log file) and documenting everything, maintaining and organized workflow.

----


2019_11_17.txt -PHD --scsi

The code must have the following characteristics/behaviours:
> Functions declared in a .py file indicate the number of particles entering into the domain trough each particular cell. It also indicates the velocity of the particles. One function for each type of particle. It is important to take into account that the velocity of the particles is a resultant between the velocity due to solar wind, and the velocity due to the temperature of that particular species. The simulation itself must be completely detached from this .py file, just receiving the information from the aforementioned functions and not providing values to the file.
> Outside boundaries are open boundaries. Every particle crossing any exterior boundary is deleted from the simulation. When calculating values in the nodes related to the particles a derivative = 0 approximation will be used. For example: velocity will be considered as the average velocity produced by the particles inside the cells involved in the calculation; density is calculated with the number of particles of such cells, and dividing by half of the usual volume computed for the rest of the cells.
> Cartesian mesh is ok for now, but let's try to keep the code as generic as possible.
> 2D is ok for now.
> I will make the E field in every node an addition between the E-field calculated with the Poisson solver, i.e. the electric field created by the interaction of the Spacecraft with the enviroment, and an external electric field that can vary from node to node. In this first simulation the external E-field will be 0.
> I highly doubt that any B-field created by the Spacecraft will become necessary to take into account at any stage of development of this code. So far, I will just add an external B-field with the same characteristic of the E-field above, being B = 0 for now.
> About the inner boundary, the particles impinging into the Spacecraft will be deleted from the mesh. The function(s) that will handle this part will receive a function that decide the number of electrons or particles created due to the incoming particle. As such, the function(s) must receive an indetermined number of species, because ablation will be included later which would mean than several types of species might be created from this impinging effect.
> The function mentioned above will make use of other function(s) that must register the current density of incoming and outcoming particles, of any species represented in the simulation. It might be passed to the previous function as an argument.
> To prevent any future interest in analyzing particular phenomena related with electrons of different origins from being difficult, the program will keep all these electrons and particles that are identical but from different sources as different species (different classes in the program). This may be organized with implementation of abstract classes, with abstract classes representing particles that are physically different, and inside each abstract class, derived classes with same physical characteristics but with different origin. 
> I think it is better to put the values of current densities in the nodes representing the Spacecraft as attributes of the classes. I should consider, in overall, putting anything related to particles in these classes. If I follow the same practice with electromagnetic fields and the rest of physical entities of importance in the simulation, I might be able to not need the 'world' class at all.
> Abstract classes of different species of particles may derive from an abstract super-class called particle. Something like that may be done with electromagnetic fields. In general, it seems as a good practice to organize this code as an object-oriented program.

----


2019_11_23.txt -PHD --scsi

> So, I am choosing Github as my repository for the code.
> The name of the project will be: SCSi (Solar Corona - Spacecraft interaction).
> At the end of each working session, I should update my computer's version and Github's repository version.
> I will construct abstract classes with 'abc.py' module.
>I will also save and keep updated the logfile "notes-PHD--scsi.txt" which is basically all the entries of this diary up to that day. The command is the following:
2019_11_23.txt rm notes-PHD--scsi.txt && for i in 201*; do awk 'BEGIN{a = 0} /-PHD --scsi/ {a = 1; print FILENAME, $0; next} /\\endInput/ {if (a ==1) print RS; a = 0; next} {if (a ==1) print $0}' $i >> notes-PHD--scsi.txt; done && cp notes-PHD--scsi.txt /home/jorge/Documents/PHD/Simulations/SCSi
> I am doing my class diagram with Inkscape following UML Class Diagram standards (I bookmarked a webpage that is very concise in explaining the standard).
Source: https://www.visual-paradigm.com/guide/uml-unified-modeling-language/uml-class-diagram-tutorial/

Construction of classes:

Notes:
> Mesh and PIC concrete classes (defined type of mesh and PIC) are closely linked. I do not want them to receive instatiation of the other so rather they will both import each other library, and will make use of the methods.
> I still have to think if I will create a Point class, how to recognize boundaries, and where to put areas of boundary points (in order to calculate fluxes).
> Also how to treat particles: Species? Just Particle class? Each particle as an object? Arrays of velocities and positions?
> Because it would be a waste of storage to keep points inside the Spacecraft, I think it is better to build the mesh between the inner and outer boundaries. Then I will create, for every different case of Spacecraft, a new file that will take care of the methods necessary to handle the inner boundary. I want to somehow detach this file and its methods from the methods that will take care of the physical phenomena. Something like this file provides the information whether a particle hit the spacecraft, but does not calculate the current nor deletes the particle. For the methods to handle outer boundaries, same standars will be applied to them. The outher boundary is closer linked to the mesh itself, but I will keep it as separate file to use the same logic as with inner boundaries. Then, every concrete mesh class will import the appropiate inner and outer boundary files, so that from outside, mesh objects can handle everything related to boundaries.
> For the first simulation I will use as the spacecraft a 1m-side cube. Therefore, the artificial depth of my code will be 1m.
> The First and outer boundaries will handle the information of the boundaries, which is why values such as nPoints, nx, ny and so on cannot be provided by the main program. They will be stored at a file called domain.py that will be imported by both boundary files.


Mesh (Abstract)(Association between Mesh and PIC):

Definition = Defines the type of mesh.
Attributes:
	+nPoints (int) = Number of points in the mesh.
	+volumes ([double]) = Volume of each node.
	+pic (PIC) = Object that provides pic methods (Association between Mesh and PIC).
Methods:
	+setDomain() = This function, with the values provided by the boundary files, will create the mesh, by setting up volumes, nPoints and any other subclass variable.
	+getPosition([int] i): [double, double y] = For a each index return its real position.
	+getVolumes() = calculates the volume of each node and stores it in volumes attribute.
	+print() = Print a VTK file / Matplotlib visualization of the mesh (points and connections between particles).

Mesh_2D_rm (Inherits from Mesh):

Definition = Mesh class for a 2D rectangular mesh.
Attributes:
	+xmin (double) = Left limit of the domain (closest to the Sun).
	+xmax (double) = Right limit of the domain (farthest from the Sun).
	+ymin (double) = Bottom limit of the domain.
	+ymax (double) = Top limit of the domain.
	+depth (double) = Artificial thickness of the domain, to make it three-dimensional.
	+nx (int) = Number of nodes in the x direction.
	+ny (int) = Number of nodes in the y direction.
Methods:
	+Implementation of Mesh methods.


PIC (Abstract)(Association between Mesh and PIC):

Definition = Indicate the methods that all PIC classes have to implement. Each PIC concrete class will depend on the type of mesh, as well as the type of PIC algorithm implemented.
Methods:
	+scatter([double, double] positions, double value, [double] field) = Receives the positions of the particles, and makes scatter procedure, calculating the values of field for each node.
	+gather([double, double] positions, [double] field): [double]field_p = Calculates values of the field in particles' positions, returning these values in an array as long as positions, called field_p.

PIC_2D_rm1o (Inherits from PIC):

Definition = PIC class for rm10 ('r'ectangular 'm'esh, '1'st 'o'rder implementation).
Methods:
	+Implementation of PIC class methods.
	+scatter_density = return densities of that species in every node of the mesh.
	+scatter_velocity = return velocities of that species in every node of the mesh.
	+scatter_flux = return flux of particles of that species into every indicated node (not all the mesh).

Species (Abstract):

Definition = This abstract class is the wrapper for everything related to particles. Any species of particles inherits from this class.
Attributes:
	+q (double) = charge of the species.
	+m (double) = mass of the species.
	+q_over_m (double) = q/m.
	+debye (double) = Debye length of the spcies.
	+spwt (int) = specific weight of the species.
	+max_n (int) = max. number of particles for the species.
	+mesh_values (Particles_In_Mesh) = object to store anything related with the particles in the mesh.
	+part_values (Particles) = oject to store anything related to the actual particles in physical space.

Proton (Inherits from Species):

Definition = Species that take care of protons.
Attributes:
	+type (string) = some string descriptor that indicate the type/source of protons.
	+Species attributes.

Electron (Inherits from Species):

Definition = Species that take care of electrons.
Attributes:
	+type (string) = some string descriptor that indicate the type/source of electrons.
	+Species attributes.

Ion (Inherits from Species):

Definition = Species that take care of ions.
Attributes:
	+type (string) = some string descriptor that indicate the type of ion.
	+Species attributes.

Neutral (Inherits from Species):

Definition = Species that take care of neutrals.
Attributes:
	+type (string) = some string descriptor that indicate the type of neutrals.
	+Species attributes.

Particles_In_Mesh (Abstract)(Composition with Species):

Definition = Store values of distributions in the mesh related with particles. It wraps all the attributes that all particles must have.
Attributes:
	+nPoints (int) = Number of nodes in the mesh (Same as mesh class).
	+density ([double]) = Density values at each node.
	+velocity ([double, double]) = Velocity at each node. Rows are different points, columns are (x,y,z) components if they are available.

Electrons_In_Mesh (Inherits from Particles_In_Mesh):

Definition = Actual implementation of Particles_In_Mesh for electrons.
Attributes:
	+flux_spacecraft ([double]) = Perpendicular flux density of electrons going in (+) or out (-) of the spacecraft. The number of rows is the number of points compounding the mesh,
									and each value represents the flux trough the line (area) next to the point (in ant-clockwise direction).
	+Particles_In_Mesh attributes.

Particles:

Definition = Stores values related with the particles themselves. (
Attributes:
	+current_n (int) = current number of particles.
	+position ([double,double]) = Position of every particle. Rows are different particles, columns are (x,y,z) if available.
	+velocity ([double,double]) = Position of every particle. Rows are different particles, columns are (x,y,z) components if available.


----


2019_11_23.txt -STOPIC --github -PHD --scsi

> Differences between "fetch" and "pull": fectch just downloads the new changes into your local repository. pull, besides that, overwrite the new changes in your local files.
> I am installing something called 'hub' that is a project that aims to wrap git and implements from command line usual actions of Github.
> I am configuring Git for my project with 'git config':
	git config --global user.name "Jorge Garcia"
	git config --global user.email "jorge-02@hotmail.es"
> Workflow from computer to server (Github website):
>> Work in my computer.
>> 'git add *': Add every new file to the git local repository. Files are 'staged' (meaning they are registered in my local git repository.
>> 'git commit -m "[Comment]"': Commit every staged file of my local repository.
>> 'git push origin master': Exactly copies the new files and files changed to the destination repository, in this case 'origin', that is an alias for my remote repository in Github. 'Master' is the branch I am pushing.
>> 'git pull origin master': Synchronizes (overwriting) branch 'master' of local repository with remote repository 'origin' ( My Github in my case).

----


2019_11_30.txt -PHD --scsi

I have founnd a document that I put in the "Papers" folder of my "PhD" folder that explains how a Capacitance matrix is created. I have to think more about it, but I suppose the idea is to establish relative capacitances between every two nodes of the mesh and every node with respect to some ground, and then, using the charge in every node from the PIC step, calculate the voltages.

----



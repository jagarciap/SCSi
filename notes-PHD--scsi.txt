2019_11_15.txt -PHD --scsi

I will start to organize my code for the next meeting with Suzuki-sensei.
> I want to start from the beginning using a tool to keep track of the changes (log file) and documenting everything, maintaining and organized workflow.

----


2019_11_17.txt -PHD --scsi

The code must have the following characteristics/behaviours:
> Functions declared in a .py file indicate the number of particles entering into the domain trough each particular cell. It also indicates the velocity of the particles. One function for each type of particle. It is important to take into account that the velocity of the particles is a resultant between the velocity due to solar wind, and the velocity due to the temperature of that particular species. The simulation itself must be completely detached from this .py file, just receiving the information from the aforementioned functions and not providing values to the file.
> Outside boundaries are open boundaries. Every particle crossing any exterior boundary is deleted from the simulation. When calculating values in the nodes related to the particles a derivative = 0 approximation will be used. For example: velocity will be considered as the average velocity produced by the particles inside the cells involved in the calculation; density is calculated with the number of particles of such cells, and dividing by half of the usual volume computed for the rest of the cells.
> Cartesian mesh is ok for now, but let's try to keep the code as generic as possible.
> 2D is ok for now.
> I will make the E field in every node an addition between the E-field calculated with the Poisson solver, i.e. the electric field created by the interaction of the Spacecraft with the enviroment, and an external electric field that can vary from node to node. In this first simulation the external E-field will be 0.
> I highly doubt that any B-field created by the Spacecraft will become necessary to take into account at any stage of development of this code. So far, I will just add an external B-field with the same characteristic of the E-field above, being B = 0 for now.
> About the inner boundary, the particles impinging into the Spacecraft will be deleted from the mesh. The function(s) that will handle this part will receive a function that decide the number of electrons or particles created due to the incoming particle. As such, the function(s) must receive an indetermined number of species, because ablation will be included later which would mean than several types of species might be created from this impinging effect.
> The function mentioned above will make use of other function(s) that must register the current density of incoming and outcoming particles, of any species represented in the simulation. It might be passed to the previous function as an argument.
> To prevent any future interest in analyzing particular phenomena related with electrons of different origins from being difficult, the program will keep all these electrons and particles that are identical but from different sources as different species (different classes in the program). This may be organized with implementation of abstract classes, with abstract classes representing particles that are physically different, and inside each abstract class, derived classes with same physical characteristics but with different origin. 
> I think it is better to put the values of current densities in the nodes representing the Spacecraft as attributes of the classes. I should consider, in overall, putting anything related to particles in these classes. If I follow the same practice with electromagnetic fields and the rest of physical entities of importance in the simulation, I might be able to not need the 'world' class at all.
> Abstract classes of different species of particles may derive from an abstract super-class called particle. Something like that may be done with electromagnetic fields. In general, it seems as a good practice to organize this code as an object-oriented program.

----


2019_11_23.txt -PHD --scsi

> So, I am choosing Github as my repository for the code.
> The name of the project will be: SCSi (Solar Corona - Spacecraft interaction).
> At the end of each working session, I should update my computer's version and Github's repository version.
> I will construct abstract classes with 'abc.py' module.
>I will also save and keep updated the logfile "notes-PHD--scsi.txt" which is basically all the entries of this diary up to that day. The command is the following:
2019_11_23.txt rm notes-PHD--scsi.txt && for i in 201*; do awk 'BEGIN{a = 0} /-PHD --scsi/ {a = 1; print FILENAME, $0; next} /\\endInput/ {if (a ==1) print RS; a = 0; next} {if (a ==1) print $0}' $i >> notes-PHD--scsi.txt; done && cp notes-PHD--scsi.txt /home/jorge/Documents/PHD/Simulations/SCSi
> I am doing my class diagram with Inkscape following UML Class Diagram standards (I bookmarked a webpage that is very concise in explaining the standard).
Source: https://www.visual-paradigm.com/guide/uml-unified-modeling-language/uml-class-diagram-tutorial/

Construction of classes:

Notes:
> Mesh and PIC concrete classes (defined type of mesh and PIC) are closely linked. I do not want them to receive instatiation of the other so rather they will both import each other library, and will make use of the methods.
> I still have to think if I will create a Point class, how to recognize boundaries, and where to put areas of boundary points (in order to calculate fluxes).
> Also how to treat particles: Species? Just Particle class? Each particle as an object? Arrays of velocities and positions?
> Because it would be a waste of storage to keep points inside the Spacecraft, I think it is better to build the mesh between the inner and outer boundaries. Then I will create, for every different case of Spacecraft, a new file that will take care of the methods necessary to handle the inner boundary. I want to somehow detach this file and its methods from the methods that will take care of the physical phenomena. Something like this file provides the information whether a particle hit the spacecraft, but does not calculate the current nor deletes the particle. For the methods to handle outer boundaries, same standars will be applied to them. The outher boundary is closer linked to the mesh itself, but I will keep it as separate file to use the same logic as with inner boundaries. Then, every concrete mesh class will import the appropiate inner and outer boundary files, so that from outside, mesh objects can handle everything related to boundaries.
> For the first simulation I will use as the spacecraft a 1m-side cube. Therefore, the artificial depth of my code will be 1m.
> The First and outer boundaries will handle the information of the boundaries, which is why values such as nPoints, nx, ny and so on cannot be provided by the main program. They will be stored at a file called domain.py that will be imported by both boundary files.


Mesh (Abstract)(Association between Mesh and PIC):

Definition = Defines the type of mesh.
Attributes:
	+nPoints (int) = Number of points in the mesh.
	+volumes ([double]) = Volume of each node.
	+pic (PIC) = Object that provides pic methods (Association between Mesh and PIC).
Methods:
	+setDomain() = This function, with the values provided by the boundary files, will create the mesh, by setting up volumes, nPoints and any other subclass variable.
	+getPosition([int] i): [double, double y] = For a each index return its real position.
	+getVolumes() = calculates the volume of each node and stores it in volumes attribute.
	+print() = Print a VTK file / Matplotlib visualization of the mesh (points and connections between particles).

Mesh_2D_rm (Inherits from Mesh):

Definition = Mesh class for a 2D rectangular mesh.
Attributes:
	+xmin (double) = Left limit of the domain (closest to the Sun).
	+xmax (double) = Right limit of the domain (farthest from the Sun).
	+ymin (double) = Bottom limit of the domain.
	+ymax (double) = Top limit of the domain.
	+depth (double) = Artificial thickness of the domain, to make it three-dimensional.
	+nx (int) = Number of nodes in the x direction.
	+ny (int) = Number of nodes in the y direction.
Methods:
	+Implementation of Mesh methods.


PIC (Abstract)(Association between Mesh and PIC):

Definition = Indicate the methods that all PIC classes have to implement. Each PIC concrete class will depend on the type of mesh, as well as the type of PIC algorithm implemented.
Methods:
	+scatter([double, double] positions, double value, [double] field) = Receives the positions of the particles, and makes scatter procedure, calculating the values of field for each node.
	+gather([double, double] positions, [double] field): [double]field_p = Calculates values of the field in particles' positions, returning these values in an array as long as positions, called field_p.

PIC_2D_rm1o (Inherits from PIC):

Definition = PIC class for rm10 ('r'ectangular 'm'esh, '1'st 'o'rder implementation).
Methods:
	+Implementation of PIC class methods.
	+scatter_density = return densities of that species in every node of the mesh.
	+scatter_velocity = return velocities of that species in every node of the mesh.
	+scatter_flux = return flux of particles of that species into every indicated node (not all the mesh).

Species (Abstract):

Definition = This abstract class is the wrapper for everything related to particles. Any species of particles inherits from this class.
Attributes:
	+q (double) = charge of the species.
	+m (double) = mass of the species.
	+q_over_m (double) = q/m.
	+debye (double) = Debye length of the spcies.
	+spwt (int) = specific weight of the species.
	+max_n (int) = max. number of particles for the species.
	+mesh_values (Particles_In_Mesh) = object to store anything related with the particles in the mesh.
	+part_values (Particles) = oject to store anything related to the actual particles in physical space.

Proton (Inherits from Species):

Definition = Species that take care of protons.
Attributes:
	+type (string) = some string descriptor that indicate the type/source of protons.
	+Species attributes.

Electron (Inherits from Species):

Definition = Species that take care of electrons.
Attributes:
	+type (string) = some string descriptor that indicate the type/source of electrons.
	+Species attributes.

Ion (Inherits from Species):

Definition = Species that take care of ions.
Attributes:
	+type (string) = some string descriptor that indicate the type of ion.
	+Species attributes.

Neutral (Inherits from Species):

Definition = Species that take care of neutrals.
Attributes:
	+type (string) = some string descriptor that indicate the type of neutrals.
	+Species attributes.

Particles_In_Mesh (Abstract)(Composition with Species):

Definition = Store values of distributions in the mesh related with particles. It wraps all the attributes that all particles must have.
Attributes:
	+nPoints (int) = Number of nodes in the mesh (Same as mesh class).
	+density ([double]) = Density values at each node.
	+velocity ([double, double]) = Velocity at each node. Rows are different points, columns are (x,y,z) components if they are available.

Electrons_In_Mesh (Inherits from Particles_In_Mesh):

Definition = Actual implementation of Particles_In_Mesh for electrons.
Attributes:
	+flux_spacecraft ([double]) = Perpendicular flux density of electrons going in (+) or out (-) of the spacecraft. The number of rows is the number of points compounding the mesh,
									and each value represents the flux trough the line (area) next to the point (in ant-clockwise direction).
	+Particles_In_Mesh attributes.

Particles:

Definition = Stores values related with the particles themselves. (
Attributes:
	+current_n (int) = current number of particles.
	+position ([double,double]) = Position of every particle. Rows are different particles, columns are (x,y,z) if available.
	+velocity ([double,double]) = Position of every particle. Rows are different particles, columns are (x,y,z) components if available.


----


2019_11_23.txt -STOPIC --github -PHD --scsi

> Differences between "fetch" and "pull": fectch just downloads the new changes into your local repository. pull, besides that, overwrite the new changes in your local files.
> I am installing something called 'hub' that is a project that aims to wrap git and implements from command line usual actions of Github.
> I am configuring Git for my project with 'git config':
	git config --global user.name "Jorge Garcia"
	git config --global user.email "jorge-02@hotmail.es"
> Workflow from computer to server (Github website):
>> Work in my computer.
>> 'git add *': Add every new file to the git local repository. Files are 'staged' (meaning they are registered in my local git repository.
>> 'git commit -m "[Comment]"': Commit every staged file of my local repository.
>> 'git push origin master': Exactly copies the new files and files changed to the destination repository, in this case 'origin', that is an alias for my remote repository in Github. 'Master' is the branch I am pushing.
>> 'git pull origin master': Synchronizes (overwriting) branch 'master' of local repository with remote repository 'origin' ( My Github in my case).

----


2019_11_30.txt -PHD --scsi

I have founnd a document that I put in the "Papers" folder of my "PhD" folder that explains how a Capacitance matrix is created. I have to think more about it, but I suppose the idea is to establish relative capacitances between every two nodes of the mesh and every node with respect to some ground, and then, using the charge in every node from the PIC step, calculate the voltages. Actually, the paper "2009_Evaluation of Electric Field Probe Onboard Spacecraft using a 3D PIC Simulation" and the book "1985_Plasma Physics via Computer Simulation_Birdsall-Langdon" both referred to the book "Computer simulation using particles / R.W. Hockney and J.W. Eastwood" when mentioning this Capacitance Matrix method. There are several copies in UTokyo so I will go on Monday to get one.

----


2019_12_02.txt -PHD --scsi

> Capacitance Matrix: So, what is the idea? The charge at any point in the spacecraft is the integral of net current to the spacecraft in from t=0 to that moment. Then, by using \vec{V} = C^{-1}\vec{Q} with \vec{Q} the charges in the nodes of of the spacecraft, V can be obtained for the same nodes.
> Another idea, called immersed boundary, is to put sufficiently large permittivities in the nodes representing the spacecraft. Using finite \rho, but "almost infinite" \epsilon, makes \nabla\phi almost vanishing, which is the intention for a conducting material.
> The conclussion of the day regarding this topic is: Calculate the charge accumulation at the nodes as mention in the first item. Probably, after each iteration, I should redistribute the charge in a way that makes the potential equal to zero. Then, in next iteration, use this previous charge in each node, plus current*timestep. Now, having this and knowing the C^{-1}, V can be calculated. which will be v_{sc}*\vec{1}. As such, the only part remaining is to find the capacity matrix. For this I have to solve the problem of finding the potential for a square at fixed potential as inner boundary, and infinite as outer boundary. I think is viable to make \phi = X(x)Z(z) and work with one quarter of the space. The potential in the diagonal boundary has to satisfy that \vec{E} perpendicular to the diagonal equals 0. Obviously, the other two boundaries are V(sc) = v_{sc} and v(\infty) = 0. Then, using Gauss law in the spacecraft, find v_{sc} such that the charge is 1. After this, make \frac{d\phi}{dz} to find the charge density and thus store the values of how a total charge Q is redistributed throughout the surface of the spacecraft.

----


2019_12_09.txt -PHD --scsi -MAESTRIA --transitorio_1D

> I can use the computer in front of the table and the MacPro one. For both of them I should check if I will interrupt or somehow affect other people's code and ask for permission.
> In the computer in fron of the table I will use Conda to run the code. Commands to use Conda:
>> conda activate jorge
>> conda deactivate

> So far, the code in /home/jorge/Documents/Instituto_Balseiro/Documentos_Maestria/Simulaciones/Preliminary_Version/source_FifeThruster is working. I will copy that version into Hayabusa 3. I also updated the error of the energy term Jj in the Dropbox folder. I corrected the (+) to (-) in the exponential term in ionization.
> I put my Master's code into Github. I have to ask Daniel about privacy issues, but in general I want to keep stored a version of the code that works, alongside my thesis and some other documents.

> The code will be working with mks system, at least for now.
> The constants of the mesh not related to the boundaries are directly written in the init function of the class.
> Addition to mesh_2D_rm:
Definition = Mesh class for a 2D rectangular mesh. The organization of the points will work as 0<=i<nx and 0<=j<ny. Also, for k parameter 0<=k<nPoints, k = nx*j+i.
#       +dx (float32) = Distance between adyacent horizontal nodes
#       +dy (float32) = Distance between adyacent vertical nodes



----


2019_12_12.txt -PHD --scsi -STOPIC --python

> After deliberating for a bit, I have decided to maintain all the classes' codes with self. I think it is clearer to read it that way afterwards and reduces the probability of coding errores related with differentiating when to declare variables and functions as class or instance attributes. I show the discussion below:
"So far I am using 'self' to define the attributes inside the classes. That means that the attribute is considered as an instance attribute rather than a class attribute. Same with functions define with 'self' as first argument. For now I will stop using 'self' in the classes that will be instanced just once, since I am adding this four additional letters unnecessarilly each time. Maybe in the future I can start using, for example, different PIC techniques for different parts of the domain, or a mesh that is a combination of different meshes. In those cases I might be instantiating multiple times the same class, and I will need then to change the code. I will stop using self for variables and I will declare them in the class scope. However, methods will still include 'self' since otherwise, to be part of the class, 'self' has to be replaced by 'cls', and it goes through more work since class methods then possibly cannot be called as instance.function_name()"

> New addition to Mesh class:
#	+getIndex([double,double] pos): [double,double] = For each real position returns its index value. Important to remember that the number of columns may vary
#           depending on the actual type of mesh subclass used.
Also, now it's not necessary to use getVolumes() so it was deleted.

----


2019_12_17.txt -PHD --scsi

> Now the classes Mesh and Mesh_2D_rm work! I printed the mesh in paraview and everything is working as expected: volumes and coordinates.
> Correction in PIC class:
#	+scatter([double, double] positions, [double] values, [double] field) = Receives the positions of the particles, and makes scatter procedure, calculating the values of field for each node.

----



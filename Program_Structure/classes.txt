## ---------------------------------------------------------------------------------------------------------------
# This file will contain the workflow in the conceptual development of classes for the simulation
# NOTE: The new additions and changes, as they occur, also have to be reported in the notes.
## ---------------------------------------------------------------------------------------------------------------

Mesh (Abstract)(Association between Mesh and PIC):

Definition = Defines the type of mesh.
Attributes:
	+nPoints (int) = Number of points in the mesh.
	+boundaries ([Boundary]) = List of different boundaries that define the mesh.
	+volumes ([double]) = Volume of each node.
Methods:
	+setDomain() = This function, with the values provided by the boundary files, will create the mesh, by setting up volumes, nPoints, boundaries and any other subclass variable.
	+getPosition([int] i): [double, double y] = For a each index return its real position.
	+getIndex([double,double] pos): [double,double] = For each real position returns its index value. Important to remember that the number of columns may vary
           depending on the actual type of mesh subclass used.
	+arrayToIndex([ind] array): [int, int] = For the indexes in the 1D array, obtain the indexes used for the particular mesh.
	+indexToArray([ind, ind] index): [int] = For the indexes used for the particular mesh, obtain the 1D version for the array.
	+print() = Print a VTK file / Matplotlib visualization of the mesh (points and connections between nodes). Also print volumes.

--------------------------------------------

Mesh_2D_rm (Inherits from Mesh):

#Definition = Mesh class for a 2D rectangular mesh. The organization of the points will work as 0<=i<nx and 0<=j<ny. Also, for k parameter 0<=k<nPoints, k = nx*j+i.
Attributes:
	+xmin (double) = Left limit of the domain (closest to the Sun).
	+xmax (double) = Right limit of the domain (farthest from the Sun).
	+ymin (double) = Bottom limit of the domain.
	+ymax (double) = Top limit of the domain.
	+depth (double) = Artificial thickness of the domain, to make it three-dimensional.
	+nx (int) = Number of nodes in the x direction.
	+ny (int) = Number of nodes in the y direction.
    +dx (float32) = Distance between adyacent horizontal nodes
    +dy (float32) = Distance between adyacent vertical nodes
	+boundaries ([Boundary]) = It is [Outer_2D_Rectangular].
	+Mesh class attributes.
Methods:
	+Implementation of Mesh methods.

---------------------------------------------------------------------------------------------------------------------------------------

PIC (Abstract)(Association between Mesh and PIC):

Definition = Indicate the methods that all PIC classes have to implement. Each PIC concrete class will depend on the type of mesh, as well as the type of PIC algorithm implemented.
Attributes:
	+mesh (Mesh) = Instance of the mesh class for later use of getIndex().
Methods:
	+scatter([double, double] positions, [double] values, [double] field) = Receives the positions of the particles, and makes scatter procedure, calculating the values of field for each node.
	+gather([double, double] positions, [double, double] field): [double, double]field_p = Calculates values of the field in particles' positions, returning these values in an array as long as positions,
                                                                                               The columns are the (x,y,z) components

--------------------------------------------

PIC_2D_rm1o (Inherits from PIC):

Definition = PIC class for rm10 ('r'ectangular 'm'esh, '1'st 'o'rder implementation).
Attributes:
	+PIC class attributes.
Methods:
	+Implementation of PIC class methods.
	+scatterDensity (Species) = return densities of that species in every node of the mesh.
	+scatterVelocity (Species) = return velocities of that species in every node of the mesh.
	+scatter_flux = return flux of particles of that species into every indicated node (not all the mesh).
	+scatter_velocity = return velocities of that species in every node of the mesh.

---------------------------------------------------------------------------------------------------------------------------------------

Species (Abstract):

Definition = This abstract class is the wrapper for everything related to particles. Any species of particles inherits from this class.
Attributes:
	+dt (double) = timestep for the motion of the particle.
	+q (double) = charge of the species.
	+m (double) = mass of the species.
	+q_over_m (double) = q/m.
	+debye (double) = Debye length of the spcies.
	+spwt (int) = specific weight of the species.
    +pos_dim (int) = number of components of position
    +vel_dim(int) = number of components of the velocity
	+mesh_values (Particles_In_Mesh) = object to store anything related with the particles in the mesh.
	+part_values (Particles) = oject to store anything related to the actual particles in physical space.
Notes:
       +__init__() receives nPoints from mesh

--------------------------------------------

Proton (Inherits from Species):

Definition = Species that take care of protons.
Attributes:
	+type (string) = some string descriptor that indicate the type/source of protons.
	+Species attributes.

--------------------------------------------

Proton_SW (Inherits from Species):

Definition = Species that take care of protons coming from solar wind.
Attributes:
	+type (string) = "Proton - Solar wind"
	+Species attributes.

--------------------------------------------

Electron (Inherits from Species):

Definition = Species that take care of electrons.
Attributes:
	+type (string) = some string descriptor that indicate the type/source of electrons.
	+Species attributes.

--------------------------------------------

Electron_SW (Inherits from Species):

Definition = Species that take care of electrons coming from solar wind.
Attributes:
	+type (string) = "Electron - Solar wind"
	+Species attributes.

--------------------------------------------

Ion (Inherits from Species):

Definition = Species that take care of ions.
Attributes:
	+type (string) = some string descriptor that indicate the type of ion.
	+Species attributes.

--------------------------------------------

Neutral (Inherits from Species):

Definition = Species that take care of neutrals.
Attributes:
	+type (string) = some string descriptor that indicate the type of neutrals.
	+Species attributes.

--------------------------------------------

Particles_In_Mesh (Abstract)(Composition with Species):

Definition = Store values of distributions in the mesh related with particles. It wraps all the attributes that all particles must have.
Attributes:
	+nPoints (int) = Number of nodes in the mesh (Same as mesh class).
	+density ([double]) = Density values at each node.
	+velocity ([double, double]) = Velocity at each node. Rows are different points, columns are (x,y,z) components if they are available.
	+residuals([double]) = remnants from injection of particles at the previous step.

--------------------------------------------

Electrons_In_Mesh (Inherits from Particles_In_Mesh):

Definition = Actual implementation of Particles_In_Mesh for electrons.
Attributes:
	+flux_spacecraft ([double]) = Perpendicular flux density of electrons going in (+) or out (-) of the spacecraft. The number of rows is the number of points compounding the mesh,
									and each value represents the flux trough the line (area) next to the point (in ant-clockwise direction).
	+Particles_In_Mesh attributes.

--------------------------------------------

Particles:

Definition = Stores values related with the particles themselves.
Attributes:
	+current_n (int) = current number of particles.
	+max_n (int) = max. number of particles for the species.
	+position ([double,double]) = Position of every particle. Rows are different particles, columns are (x,y,z) if available.
	+velocity ([double,double]) = Position of every particle. Rows are different particles, columns are (x,y,z) components if available.

---------------------------------------------------------------------------------------------------------------------------------------

Field (Abstract):

Definition = Indicate the attributes and methods that all fields have to implement. The fields obtain the functions to compute the fields from 'solver.py'
Attributes:
	+pic (PIC) = Class that contains PIC methods.
	+boundaries ([Boundary]) = Class that represents the methods which apply boundaries to the fields.
	+nPoints (int) = number of nodes in the mesh (Same as mesh class).
	+field ([double, double]) = components (columns) of field at each node.
Methods:
	+__init__(...) = This function, for each subclass, will take care of the initial condition of the field.
	+computeField([Species] species) = Computes the updated field values.
	+fieldAtParticles([double,double] position) [double,double] = return an array indicating by component (columns) and particles (rows) the field at every position.

--------------------------------------------

Electric_Field (Inherits from Field):

Definition = Electric field
Attributes:
	+type (string) = some string that describes the source of the electric field (created by the interaction plasma-spacecraft, user-defined, constant, etc.)
	+potential ([double]) = Electric potential at each node of the mesh.
	+Field attributes.
Methods:
	+Field methods.

--------------------------------------------

Constant_Electric_Field(Inherits from Electric_Field):

Definition = Constant electric field impsoed by the user. Does not change through time.
Attributes:
	+type (string) = "Electric field - Constant".
	+Electric_Field attributes.
Methods:
	+Electric_Field methods.

--------------------------------------------

Magnetic_Field (Inherits from Field):

Definition = Magnetic field
Attibutes:
	+type (string) = some string that describes the source of the magnetic field (created by the interaction plasma-spacecraft, user-defined, constant, etc.)
	+Field attributes.
Methods:
	+Field methods.

---------------------------------------------------------------------------------------------------------------------------------------

Boundary (Abstract-like: will also have common methods that can be used by sub-classes. In composition with mesh):

Definition = Class that shows the methods and attributes needed for each particular boundary arrangement.
Attributes:
	+type (string) = string indicating the type of boundary. It will be of the form "[Inner or Outer] - [Sorce, e.g. Spacecraft, Component, etc.]".
	+location ([int]) = array containing the indices of the nodes that the boundary represents.
Methods:
	+applyElectricBoundary([double]) = Applies the boundary condition to the electric field passed as argument.
	+applyMagneticBoundary([double]) = Applies the boundary condition to the magnetic field passed as argument.
	+applyParticleBoundary(Species) = Applies the boundary condition to the species passed as argument.
    +createDummyBox([ind]location, PIC pic, Species species, [double] delta_n, [double] n_vel, [double] shift_vel) = create the dummy boxes with particles in them.
   
Methods stored here for convenience:
    +injectParticlesFace(self, location, pic, species, delta_n, n_vel, shift_vel): 
   	++Function that inject particles into the domain.
   	++Parameters: 
   	++location ([ind]) = Nodes indicating the faces where the particles are going to be inserted. Each node represents the volume surrounding it. Location should be ordered increasingly.
   	++pic (PIC) = Instance of PIC for calculations. It also constains mesh, which is used in the function.
   	++species (Species) = Species to be inserted. It contains inside Particles_In_Mesh 'residuals' which is for each node the values of remnants from the insertion at the previous step.
   	++delta_n ([double]) = For each node in location, the density that is going to be inserted at this timestep. The array is ordered with the order of the nodes in mesh.
   	++n_vel ([double,double]) = For each node in location, the thermal velocity (for a the MB distribution) that the inserted particles will represent. Same order as delta_n.
	++shit_vel ([double, double]) = For each node in location, an added velocity that does not come from temperature origin (like solaw wind average speed.

	+injectParticlesDummyBox([int] location, PIC pic, Species species, [double] delta_n, [double] n_vel, [double] shift_vel) = Inject the particles in location indices by creating dummy boxes around them, creating particles
		inside of them, moving the particles, and then adding the ones that entered into the computational domain.

    +addParticles(Species species, [double, double] pos, [double, double] vel) = Add to Species the new particles, each represented by a row in pos and vel.
    +removeParticles(Species species, [ind] ind) = Removes the particles from species stored at 'ind' positions.
    +sampleIsotropicVelocity(double vth, int num) = It receives the most probable speed vth = \sqrt{2kT/m} and creates num random 2D velocities with their magnitudes following a Maxwellian distribution.

--------------------------------------------

Outer_2D_Rectangular (Inherits from Boundary):

Definition = Outer boundary for a rectangular mesh
Attributes:
	+type (string) = "Outer - Domain"
	+xmin (double) = Left limit of the domain (closest to the Sun).
	+xmax (double) = Right limit of the domain (farthest from the Sun).
	+ymin (double) = Bottom limit of the domain.
	+ymax (double) = Top limit of the domain.
	+location ([int]) = Boundary attribute.
Methods:
	+Boundary methods.

---------------------------------------------------------------------------------------------------------------------------------------

Motion_Solver(Abstract-like: As with Boundary, some methods can be applied to various motion solvers, so they will be stored here):

Definition = Class that shows which methods and attributes need to have all motion solvers.
Attributes:
	+type (string) = string indicating the type of scheme.
    +pic_slv (PIC) = PIC solver. For this class specific methods not provided by PIC super class are used.
Methods:
	+initialConfiguration(Species, [Field]) = Make necessary adjustment to the initial configuration of species so as to begin the advancement in time.
		it also takes care of the first update of Particle values in mesh. 
	+advance(Species, [Field]) = Advance the particles in time. It will treat the particles as well as update the mesh_values.
	+updateMeshValues(Species) = Update the attributes of Particles_In_Mesh.
	+updateParticles(Species, [Field]) = Particle advance in time.

--------------------------------------------

Leap_Frog(Inherits from Motion_Solver):

Definition = Implementation of Leap_Frog method. This method, as being more specific, is more dependant on the current situation of each simulation. As such it has to
               be updated or new classes has to be created if the situation varies.
Attributes: 
	+type (string) = "Leap Frog"
    +pic_slv (PIC) = PIC solver. For this class specific methods not provided by PIC super class are used.
Methods:
	+initialConfiguration(Species, Field) = Make necessary adjustment to the initial configuration of species so as to begin the advancement in time.
	    it also takes care of the first update of Particle values in mesh. So far just E, so [Field]->Field.
	+rewindVelocity(species, field) = Take the velocity of particles half a step back in time for 'field' electric field.
	+updateMeshValues(Species) = Update the attributes of Particles_In_Mesh. Particular for each species, so it needs to be updated with every new species.
	+updateParticles(Species, Field) = Particle advance in time. So far only E, so [Field]->Field in argument.
	+Motion_Solver methods.
